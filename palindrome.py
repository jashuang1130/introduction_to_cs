{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Hello World\n"
     ]
    }
   ],
   "source": [
    "print('Hello World')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def isPalindrome(string):\n",
    "    palindrome = False\n",
    "    reversed_string = ''.join(reversed(string))\n",
    "    if string == reversed_string:\n",
    "        palindrome = True\n",
    "        \n",
    "    return palindrome\n",
    "\n",
    "# isPalindrome('test')\n",
    "# isPalindrome('abbabba')\n",
    "\n",
    "def rotationPalindrome(string):\n",
    "    if isPalindrome(string):\n",
    "        return True\n",
    "    \n",
    "    # Now try all rotations one by one \n",
    "    n = len(string) \n",
    "    for i in range(n-1): \n",
    "        string1 = string[i + 1:n] \n",
    "        string2 = string[0:i + 1] \n",
    "        print(string1, string2)\n",
    "        \n",
    "        # Check if this rotation is palindrome \n",
    "        string1+=(string2) \n",
    "        print('final', string1)\n",
    "        if isPalindrome(string1): \n",
    "            return True\n",
    "  \n",
    "    return False\n",
    "\n",
    "rotationPalindrome('abcba')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "21"
      ]
     },
     "execution_count": 25,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# time complexity O(log(n))\n",
    "# 1 = n/2^i  => i = log n\n",
    "def bisection_search(L, e):\n",
    "    if L == []:\n",
    "        # constant O(1)\n",
    "        return False\n",
    "    elif len(L) == 1:\n",
    "        # constant O(1)\n",
    "        return L[0] == e\n",
    "    else:\n",
    "        half = len(L)//2  # constant O(1)\n",
    "        # recursive call O(nlog(n))\n",
    "        if L[half] > e:\n",
    "            return bisection_search(L[:half], e) # L[:half] makes a new list, slows down\n",
    "        else:\n",
    "            return bisection_search(L[half:], e)\n",
    "\n",
    "def alternative_bisection_search(L, e):\n",
    "    # Look at some list instead of creating new lists - doesn't need to copy lists\n",
    "    # recursive is O(1)?\n",
    "    def bisect_search_helper(L, e, low, high):\n",
    "        if high == low:\n",
    "            return L[low] == e\n",
    "        mid = (low + high)//2\n",
    "        if L[mid] == e:\n",
    "            return True\n",
    "        elif L[mid] > e:\n",
    "            if low == mid: #nothing left to search\n",
    "                return False\n",
    "            else:\n",
    "                return bisect_search_helper(L, e, low, mid - 1)\n",
    "        else:\n",
    "            return bisect_search_helper(L, e, mid + 1, high)\n",
    "        \n",
    "    if len(L) == 0:\n",
    "        return False\n",
    "    else:\n",
    "        return bisect_search_helper(L, e, o, len(L) - 1)\n",
    "    \n",
    "# O() for iterative factorial = O(n)\n",
    "def factorial_iterative(n):\n",
    "    prod = 1\n",
    "    for i in range(i, n+1):\n",
    "        prod *= i\n",
    "    return prod\n",
    "\n",
    "# O() for recursive factorial = O(n); may take longer time but same order of growth\n",
    "def factorial_recursive(n):\n",
    "    '''assume n >= 0 '''\n",
    "    if n <= 1:\n",
    "        return 1\n",
    "    else:\n",
    "        return n * factorial_recursive(n - 1)\n",
    "\n",
    "# Log Linear nLog(n) ex: merge sort\n",
    "\n",
    "# Polynomial complexity O(n^2). common in nested loops or recursive function calls\n",
    "\n",
    "# Exponential complexity O(2^n). Towers of Hanoi. WANT TO AVOID!!!\n",
    "# recursive function where there is more than one recursive call for each size of problem\n",
    "\n",
    "# Power set - given a set of integers (with no repeats), \n",
    "# want to generate the collection of all possible subsets \n",
    "# {1, 2, 3, 4} would generate (order doesn't matter)\n",
    "# {}, {1}, {2}, {3}, {4}, {1,2}, {1,3}, {1,4}, {2,3}, {2,4}, {3,4},\n",
    "# {1,2,3}, {1,2,4}, {1,3,4},{2,3,4},{1,2,3,4}\n",
    "\n",
    "# power set of 0 = {}\n",
    "# power set of 1 = {1}\n",
    "# power set of 2 = {2}, {1,2}\n",
    "# power set of 3 = {3}, {1,3}, {2,3}, {1,2,3}\n",
    "# power set of 4 = {4}, {1,4}, {2,4}, {1,2,4},{3,4},{1,3,4},{2,3,4},{1,2,3,4}\n",
    "def gen_power_subset(L):\n",
    "    if len(L) == 0:\n",
    "        return [[]] # list of empty list\n",
    "    \n",
    "    smaller = gen_power_subset(L[:-1]) # all subset without last element\n",
    "    extra = L[-1:] # create a list of just last element\n",
    "    new = []\n",
    "    for small in smaller:\n",
    "        new.append(small+extra) # for all smaller solutions, add one with last element\n",
    "    \n",
    "    return smaller+new # combine those with last element and those without\n",
    "\n",
    "'''\n",
    "SUMMARY:\n",
    "    O(1) - code doesn't depend on size of problem\n",
    "    O(log n) - reduce probblem in half each time through process \n",
    "    O(n) - simple iterative or recursive programs\n",
    "    O(n log n) Log Linear -\n",
    "    O(n^c) - nested loops or recursive calls\n",
    "    O(c^n) - multiple recursive calls at each level\n",
    "'''\n",
    "\n",
    "# Complexity of iterative fibonacci\n",
    "def iterative_fibonacci(n):\n",
    "    if n == 0:       # O(1)\n",
    "        return 0\n",
    "    elif n == 1:     # O(1)\n",
    "        return 1\n",
    "    else:\n",
    "        fib_i = 0\n",
    "        fib_ii = 1\n",
    "        for i in range(n-1):   # O(n)\n",
    "            temp = fib_i\n",
    "            fib_i = fib_ii\n",
    "            fib_ii = temp + fib_i\n",
    "        return fib_ii\n",
    "    \n",
    "# Complexity of recursive fibonacci - exponential growth: golden ratio to nth power\n",
    "def recursive_fibonacci(n):\n",
    "    \"\"\" assumes n an int >= 0 \"\"\"\n",
    "    if n == 0:     # O(1)\n",
    "        return 0\n",
    "    elif n == 1:   # O(1)\n",
    "        return 1\n",
    "    else:   # O(2^n)\n",
    "        return recursive_fibonacci(n-1) + recursive_fibonacci(n-2)\n",
    "    \n",
    "recursive_fibonacci(8)\n",
    "\n",
    "# Searching and Sorting Algorithms\n",
    "# Search - find a item or group of items from a collection\n",
    "# Log Linear Algorithm\n",
    "# Linear Search O(n): Exausive Numeration/Brute-force (British Museum Algorithm) Search - go throug every options\n",
    "#   - list doesn't need to be sorted\n",
    "# Bisection Search O(log ns) - List MUST be sorted - keep splitting collection into smaller pieces\n",
    "\n",
    "# When does it make sense to sort first then search?\n",
    "# SORT + O(log n) < O(n) -> SORT < O(n) - O(log n)\n",
    "# when sorting is less than O(n) NEVER TRUE!!!\n",
    "\n",
    "# Amortized Cost - sort first then can be used for many of future searches\n",
    "# SORT + K * O(log n ) < K * O(n) -> for large K, SORT time becomes irrelevant if cost of sorting is small enough\n",
    "\n",
    "# Monkey Sort (Permutation Sort) aka. bogosort, stupid sort, slowsort, shotgun sort. scattered n^n \n",
    "def bogo_sort(L):\n",
    "    while not is_sorted(L):\n",
    "        random.shuffle(L)\n",
    "# best case: O(n); worst case O(?) n^n\n",
    "\n",
    "# Bubble Sort   - compare consecutive pairs of elements, swap elements and start over hwne reaches the end of list.\n",
    "#               - stop when no more swaps have been made\n",
    "#               - largest will be at end of list \n",
    "def bubble_sort(L): # at most n times through the list\n",
    "    swap = False\n",
    "    while not swap:\n",
    "        swap = True\n",
    "        for i in range(1, len(L)): # multiple passes until no more swaps\n",
    "            if L[i-1] > L[i: # inner loop: comparison\n",
    "                swap = False\n",
    "                temp = L[i]\n",
    "                L[i] = L[i-1]\n",
    "                L[j-1] = temp\n",
    "                          \n",
    "# Selection Sort - find smallest element and put it in front\n",
    "#               1. extract min element, swap it w/ element at index 0\n",
    "#               2. we know smallest is at 0; we then look at smalles from index of 1 to last and swap with 1         \n",
    "# Loop invariant \n",
    "#   Base case: prefix empty, suffix while list - ivariant True\n",
    "#   induction setp: move min element from suffix to end of prefix. since invariant true before move, prefix sorted after append\n",
    "#   when exit, prefix is entire list, suffix fempty, so sorteds\n",
    "def selection_sort(L): \n",
    "    suffixSt = 0\n",
    "    while suffixSt != len(L):\n",
    "        for i in range(suffixSt, len(L)):\n",
    "            if L[i] < L[suffixSt]:\n",
    "                L[suffixSt], L[i] = L[i], L[suffixSt]\n",
    "        suffixSt += 1\n",
    "\n",
    "# Merge Sort - divide an conquer\n",
    "# split list in half until have sublist of only one element\n",
    "# merge sorted sublists. sublists will be sorted after merge\n",
    "                          \n",
    "# Merging Sublists \n",
    "def merge(left, right):\n",
    "    result = []\n",
    "    i, j = 0, 0\n",
    "    while i < len(left) and j < len(right):\n",
    "        if left[i] < right[j]:\n",
    "            result.append(left[i])\n",
    "            i += 1\n",
    "        else:\n",
    "            result.append(right[j])\n",
    "            j += 1\n",
    "    while (i < len(left)):  # everything that's left on the left-list. append to end\n",
    "        result.append(left[i])\n",
    "        i += 1\n",
    "    while (j < len(right)): # everything that's left on the right-list. append to end\n",
    "        result.append(right[j])\n",
    "        j += 1\n",
    "    return result\n",
    "\n",
    "def merge_sort(L):\n",
    "    if len(L) < 2:\n",
    "        return L[:]\n",
    "    else:\n",
    "        middle = len(L)//2\n",
    "        left = merge_sort(L[:middle])\n",
    "        right = merge_sort(L[middle:])\n",
    "        return merge(left, right)\n",
    "                          \n",
    "# divide list into halves\n",
    "# depth-first such that conquer smallest pieces down one branch first before moving to larger pieces\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
